{"mappings":"2CAagBA,GAAYC,YAACA,IAC3BC,EAAAC,aAAa,aACXF,EAEAG,SAEEC,KAAKC,OAAS,IAcdD,KAAKE,IAtBIC,UAsBcC,QAAM,CAAGC,EAAQC,KAC/B,CACLC,KAAM,EACNC,IAAK,UACLC,KAAM,MAOVT,KAAKU,YAjCPC,UAiC+B,OAAQC,IAEnCA,EAAIC,OAAUC,IACZF,EAAIG,WAAaH,EAAIG","sources":["packages/mocyang-mock/src/index.js"],"sourcesContent":["/**\n * @Author: MocYang\n * @Email: 958292256@qq.com\n * @Date: 2022/1/6 11:24\n * @File: index.js\n * @Description\n */\n\nimport { createServer } from 'miragejs'\n// import { urlNoMock, addressConfig } from './config' // 不想被 migrate 拦截的请求\n\nlet urlNoMock, addressConfig\n\nexport function makeServer({ environment }) {\n  createServer({\n    environment,\n\n    routes() {\n      // this.namespace = '/fake'\n      this.timing = 1000\n\n      /**\n       * mockAPI可以像这样，在下面添加路由配置, 这样，实际的请求路径为：/fake/api/xxx/xxx。\n       * 也就是，所有带 `/fake`前缀的请求，都将走 migratejs 的 mock 服务。其它没有这个前缀的。走正常请求\n       * this.get('/api/xxx/xxx',(schema, request) => {\n       *   return {\n       *     \"code\": 1,\n       *     \"msg\": \"success\",\n       *     \"data\": []\n       *   }\n       * })\n       */\n\n      this.get(addressConfig.getXXX, (schema, request) => {\n        return {\n          code: 0,\n          msg: 'success',\n          data: 0\n        }\n      })\n\n      /**\n       * 参考： https://miragejs.com/api/classes/server/#passthrough\n       */\n      this.passthrough(urlNoMock + '/**', (req) => {\n        // 以下方法调用为必须。目的是把透过 miragejs 的请求，响应之后，传回 axios 本身\n        req.onload = (e) => {\n          req.onloadend && req.onloadend()\n        }\n      })\n    }\n  })\n}\n"],"names":["$d5e7c9645b0c0b6b$export$74d5f2aa03dcc684","environment","$b8GJB$miragejs","createServer","routes","this","timing","get","$d5e7c9645b0c0b6b$var$addressConfig","getXXX","schema","request","code","msg","data","passthrough","$d5e7c9645b0c0b6b$var$urlNoMock","req","onload","e","onloadend"],"version":3,"file":"index.js.map"}