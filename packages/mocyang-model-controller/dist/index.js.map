{"mappings":"6OAgBMA,gBAEFC,KAAKC,OAAS,CACZC,GAAI,GAEwBC,KAAtB,eAICC,EAASC,GAClB,IAAKC,EAAAC,WAAWH,GACd,MAAM,IAAII,MAAM,sCAElB,MAAMC,EAAOT,KACb,OAAO,IAAIU,SAAOC,MAAOC,IACvB,MAAMC,QAAiBT,IACvBK,EAAKK,MAAMD,EAASV,MACpBS,OAKsBG,IAAtBC,GAGF,OAFAhB,KAAKc,MAAME,GAEJhB,KAOTc,MAAMG,GACJ,IAAKX,EAAAY,QAAQD,GACX,MAAM,IAAIT,MAAM,uCAElB,MAAMW,EAASnB,KAAKC,OAQpB,OANgCkB,EAAzBjB,GAAKkB,MAAMC,KAAK,IAAIC,IAAI,IAAIH,EAAOjB,MAAOe,EAAOM,KAAIC,GAAQA,EAAKtB,QACzEiB,EAAOhB,KAAOc,EAAOQ,QAAM,CAAEC,EAAGC,KAC9BD,EAAEC,EAAEzB,IAAMyB,EACHD,IACNP,EAAOhB,MAEHH,KAIqB4B,MAC5B,OAAOC,OAAOC,OAAO9B,KAAKC,OAAOE,MAQnC4B,OAAOC,GACL,MAAMC,EAAYjC,KAAK4B,MAEvB,GAAItB,EAAAC,WAAWyB,GACb,OAAOC,EAAUF,OAAOC,GAQ5BE,gBAEE,OADkBlC,KAAK4B,MACNG,QAAOI,IAAMA,EAAEC,SASlCC,aAAaC,EAAOC,GAClB,MAAMN,EAAYjC,KAAK4B,MAEjBY,EAAO,GAAMF,KAASC,IAC5B,OAAON,EAAUF,QAAOI,GAAKA,EAAEM,WAAaH,GAASH,EAAEO,WAAaF,IAQtEG,IAAIzC,GACF,OAAOF,KAAKC,OAAOE,KAAKD,GAS1B0C,gBAAgBC,EAAMC,EAAQC,GAC5BA,EAAUzC,EAAA0C,OAAO,CACfC,KAAM,IAENC,UAAW5C,EAAA6C,KAGXC,WAAY9C,EAAA6C,MACXJ,GAEH,MAAOE,KACLA,EAAIC,UACJA,EAASE,WACTA,GACEL,EAEJ,IAAKzC,EAAAY,QAAQ4B,GAEX,YADAO,QAAQC,MAAM,qCAAuChD,EAAAiD,aAAaT,IAIpE,MAAMU,GAAS,IAAIC,KACbC,EAAaZ,EAAOa,OACpBC,EAAQ,CAAIC,EAAaC,EAAY,KACzC,MAAMC,EAAcjB,EAAOkB,MAAMH,EAAaC,GAC1CD,EAAcH,EAAa,EAC7BO,YAAU,KACR,MAAMC,GAAO,IAAIT,KACjBJ,QAAQc,IAAG,MAAET,eAAoBQ,EAAAV,GAAU,UAE3BJ,GAAFA,EAAW,CACvBgB,SAAU,MAGZlB,GAAaA,MAIZ,GAIDL,EAAKwB,wBAEPxB,EAAKwB,uBAAuBN,GAAcO,IACpCT,EAAcH,IAChBN,GAAcA,EAAW,CACvBgB,SAAUG,KAAKhC,MAAMgC,KAAKC,IAAI,GAAI,IAAMX,EAAcH,GAAc,OAEtEO,YAAU,KACRL,EAASE,EAAWA,EAAYb,KAC/B,SAMXW,EAAS,EAAGX,QA2BhBwB,EAAe,wBArBXzE,KAAK0E,YAAc,IAAIC,IAGzBC,OAAOC,GACL,IAAKA,EACH,MAAM,IAAIrE,MAAM,+BAElB,MAAMsE,EAAkB9E,KAAK+E,IAAIF,GACjC,GAAIC,EACF,OAAOA,EAET,MAAME,EAAa,IAAIjF,EAEvB,OADAC,KAAK0E,YAAYO,IAAIJ,EAAKG,GACnBhF,KAAK+E,IAAIF,GAGlBE,IAAIG,GACF,OAAOlF,KAAK0E,YAAYK,IAAIG","sources":["packages/mocyang-model-controller/src/index.js"],"sourcesContent":["/**\n * @Author: MocYang\n * @Email: 958292256@qq.com\n * @Date: 2021/12/26 14:47\n * @File: index.js\n * @Description 模型控制器, 处理模型相关逻辑.(添加,删除,更新,查找)\n */\n\nimport {\n  isFunction,\n  isArray,\n  extend,\n  NOOP,\n  toTypeString\n} from 'mocyang-utils'\n\nclass ModelController {\n  constructor() {\n    this.models = {\n      id: [],\n      // 原始数据和id的映射,用来方便查找\n      data: {}\n    }\n  }\n\n  async load(fetchFn, options) {\n    if (!isFunction(fetchFn)) {\n      throw new Error('Expected a function to fetch data!')\n    }\n    const self = this\n    return new Promise(async resolve => {\n      const response = await fetchFn()\n      self.cache(response.data)\n      resolve()\n    })\n  }\n\n  // 可以额外添加接口之外的数据\n  add(source) {\n    this.cache(source)\n\n    return this\n  }\n\n  /**\n   * 缓存接口返回的数据.\n   * @param source[Array] 接口返回的数据,数据格式\n   */\n  cache(source) {\n    if (!isArray(source)) {\n      throw new Error('parameter error. not expected type.')\n    }\n    const target = this.models\n    // 缓存时,合并已有的数据,并插入新数据\n    target.id = Array.from(new Set([...target.id, ...source.map(item => item.id)]))\n    target.data = source.reduce((t, c) => {\n      t[c.id] = c\n      return t\n    }, target.data)\n\n    return this\n  }\n\n  // 返回当前控制器中缓存的所有数据\n  all() {\n    return Object.values(this.models.data)\n  }\n\n  /**\n   * 对所有模型数据进行过滤\n   * @param type 传入的要过滤的函数\n   * @returns {*}\n   */\n  filter(type) {\n    const allModels = this.all()\n\n    if (isFunction(type)) {\n      return allModels.filter(type)\n    }\n  }\n\n  /**\n   * 过滤出室外的模型\n   * @returns {*}\n   */\n  filterOutdoor() {\n    const allModels = this.all()\n    return allModels.filter(m => !m.indoor)\n  }\n\n  /**\n   * 分层过滤模型\n   * @param build{String} 建筑ID: V001JZ0001\n   * @param floor{String} 楼层名: F001\n   * @returns {Array<Object>}\n   */\n  filterIndoor(build, floor) {\n    const allModels = this.all()\n    // \"V001_JZ0003#F003\" 因为接口数据中的 floor_id 是完整的建筑Id+楼层名, 所以这里进行拼接\n    const floorId = `${build}#${floor}`\n    return allModels.filter(m => m.build_id === build && m.floor_id === floorId)\n  }\n\n  /**\n   * 查找指定ID的数据\n   * @param id\n   * @ret urns {*}\n   */\n  one(id) {\n    return this.models.data[id]\n  }\n\n  /**\n   * 批量添加模型\n   * @param mapV   {Object}\n   * @param source {Array<Object>}\n   * @param options {Object}\n   */\n  batchedAddModel(mapV, source, options) {\n    options = extend({\n      size: 100,\n\n      onSuccess: NOOP,\n\n      // onProgress(): {progress: number}\n      onProgress: NOOP\n    }, options)\n\n    const {\n      size,\n      onSuccess,\n      onProgress\n    } = options\n\n    if (!isArray(source)) {\n      console.error('type source must be an array, got '+ (toTypeString(source)))\n      return\n    }\n\n    const start = +new Date()\n    const sourceSize = source.length\n    const addModel = (startOffset, endOffset = 0) => {\n      const sourceSlice = source.slice(startOffset, endOffset)\n      if (startOffset > sourceSize - 1) {\n        setTimeout(() => {\n          const end = +new Date()\n          console.log(`加载 ${sourceSize} 个模型,共耗时: ${(end - start) / 1000}s. `)\n\n          onProgress && onProgress({\n            progress: 100\n          })\n\n          onSuccess && onSuccess()\n\n          // 把所有带有GID的对象的配置，缓存起来。方便后面进一步操作\n\n        }, 0)\n        return\n      }\n\n      if (mapV.OverLayerCreateObjects) {\n        // 注意,此功能为异步操作\n        mapV.OverLayerCreateObjects(sourceSlice, (res) => {\n          if (startOffset < sourceSize) {\n            onProgress && onProgress({\n              progress: Math.floor(Math.pow(10, 4) * (startOffset / sourceSize) / 100)\n            })\n            setTimeout(() => {\n              addModel(endOffset, endOffset + size)\n            }, 10)\n          }\n        })\n      }\n    }\n\n    addModel(0, size)\n  }\n}\n\nclass ModelControlManager {\n  constructor() {\n    this.controllers = new Map()\n  }\n\n  create(key) {\n    if (!key) {\n      throw new Error('controller key is required!')\n    }\n    const existController = this.get(key)\n    if (existController) {\n      return existController\n    }\n    const controller = new ModelController()\n    this.controllers.set(key, controller)\n    return this.get(key)\n  }\n\n  get(key) {\n    return this.controllers.get(key)\n  }\n}\n\nexport default new ModelControlManager()\n\n\n"],"names":["$24c76d36157eed72$var$ModelController","this","models","id","data","fetchFn","options","$atzTN$mocyangutils","isFunction","Error","self","Promise","async","resolve","response","cache","add","source","source1","isArray","target","Array","from","Set","map","item","reduce","t","c","all","Object","values","filter","type","allModels","filterOutdoor","m","indoor","filterIndoor","build","floor","floorId","build_id","floor_id","one","batchedAddModel","mapV","source2","options1","extend","size","onSuccess","NOOP","onProgress","console","error","toTypeString","start","Date","sourceSize","length","addModel","startOffset","endOffset","sourceSlice","slice","setTimeout","end","log","progress","OverLayerCreateObjects","res","Math","pow","$24c76d36157eed72$export$2e2bcd8739ae039","controllers","Map","create","key","existController","get","controller","set","key1"],"version":3,"file":"index.js.map"}